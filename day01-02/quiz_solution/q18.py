# Q18. `x = y[:]`와 `x = list(y)`는 어떤 차이가 있나요?

# 둘 다 얕은 복사지만 x = y[:]는 슬라이싱, x = list(y)는 생성자 사용.
# 의미는 같으나 타입 확장에 따라 다르게 동작 가능.

# ✅ 공통점
# 항목	    설명
# 목적	    둘 다 얕은 복사(shallow copy) 수행
# 결과	    새로운 리스트 객체를 생성, 원본과는 별개의 객체
# 메모리	x is not y (다른 주소)
# 값 비교	x == y (내용은 동일)


# ⚖️ 차이점 비교: y[:] vs list(y)
# 항목	              y[:]	                     list(y)
# 방식	            슬라이싱	                    생성자 호출
# 속도	            보통 더 빠름 (순수 리스트일 경우)	 약간 느릴 수 있음
# 타입 처리	          무조건 리스트여야 함	            이터러블이면 모두 가능
# 하위 클래스 처리	   하위 클래스 유지	                항상 list 타입으로 강제


# 🔍 실험 1: 슬라이싱은 리스트에서만 가능
y = [1, 2, 3]
x1 = y[:]        # ✅
x2 = list(y)     # ✅


y = (1, 2, 3)
x1 = y[:]        # ✅ 튜플도 슬라이싱 가능
x2 = list(y)     # ✅ 리스트로 변환


y = {1, 2, 3}
x1 = y[:]        # ❌ TypeError
x2 = list(y)     # ✅ [1, 2, 3]

# 👉 list(y)는 이터러블이면 모두 복사 가능
# 👉 y[:]는 슬라이싱 가능한 시퀀스 타입에만 동작



# 🔍 실험 2: 하위 클래스
class MyList(list):
    pass

y = MyList([1, 2, 3])
x1 = y[:]           # ✅ x1의 타입: MyList
x2 = list(y)        # ✅ x2의 타입: list (하위 클래스 → 기본 클래스화)

print(type(x1))     # <class '__main__.MyList'>
print(type(x2))     # <class 'list'>

# → list()는 항상 내장 list 타입을 반환
# → [:]는 원래 클래스 유지


# 🧠 요약
# 비교 항목	            y[:]	                   list(y)
# 복사 방식	            슬라이싱	                 리스트 생성자
# 작동 조건	            슬라이싱 가능한 시퀀스	        모든 이터러블 객체
# 하위 클래스 유지	     ✅ 유지	                    ❌ 무시하고 list로 변환
# 성능	              보통 더 빠름	                약간 느릴 수 있음


# ✅ 추천 가이드
# 상황	추천 방식
# 리스트 복사만 필요	y[:]
# 이터러블 전체 복사	list(y)
# 타입 유지가 중요할 때 (ex. 하위 클래스)	y[:]
# 다른 타입으로 바꾸고 싶을 때	list(...)
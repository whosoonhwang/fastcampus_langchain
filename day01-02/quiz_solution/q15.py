# Q15. 다음 코드를 실행하면 어떤 결과가 나올까요? 이유도 설명하세요.

def f(x): x += [4]
a = [1,2,3]
f(a)
print(a)

# 출력
# [1,2,3,4]

# 왜 이렇게 나오는지 이해하기
# x += [...]는 리스트에 대해선 x.extend(...)처럼 작동

# ❓ 왜 이렇게 나오는가?
# 🔍 핵심 포인트: x += [4]는 x.extend([4])처럼 작동하며, 리스트 자체를 수정(mutate)

# 📚 배경: += 연산자의 두 가지 의미
# 파이썬에서 x += y는 다음 두 단계를 내포합니다:

# 1. x.__iadd__(y) (in-place add) → 가능하면 원본을 수정

# 2. 만약 __iadd__()가 없다면 → **x = x + y**처럼 작동 (새 객체 생성)


# 🎯 리스트에서는 어떻게 동작하나?
# 리스트(list)는 mutable하고 __iadd__를 구현하고 있음

# 따라서 x += [4]는 원래 리스트 객체의 내부에 [4]를 확장하는 식으로 작동

# 즉, 다음과 동일함:
# x.extend([4])

# 따라서 원본 리스트 a도 변경됨


# 🧠 메모리 흐름 시각화

# 1. 초기 상태:
# a = [1, 2, 3]

# 2. f(a) 호출:
# x ──► [1, 2, 3]

# f(a)  # 내부에서 x += [4]

# 3. 결과:
# a ──► [1, 2, 3, 4]



# 🔁 반례: 불변 객체에서의 +=

def f(x):
    x += 1

a = 10
f(a)
print(a)  # 10


# 이 경우 x += 1은 x = x + 1과 동일하게 동작하고
# → 새로운 int 객체를 만들어 x에 재바인딩하므로 a는 영향을 받지 않음



# 🧪 실험 예제 비교
def f(x):
    print("Before:", id(x))
    x += [4]
    print("After:", id(x))

a = [1, 2, 3]
print("Original:", id(a))
f(a)
print("Final:", a)

# Original: 140330...
# Before:   140330...
# After:    140330...   ← 같은 객체!
# Final:    [1, 2, 3, 4]


# 🔄 요약
# 연산자	대상	               작동 방식	            외부 객체에 영향?
# +=	리스트(list)	          내부 객체 수정 (extend)	✅ 있음
# +=	숫자(int) 등 불변 객체	    새 객체 생성, 재바인딩	    ❌ 없음


# 🔍 실전 예제: 딕셔너리 수정
def f(x):
    x['a'] = 99

a = {'a': 100}
# Q11. 리스트는 가변 객체입니다. 이 특징으로 인해 생길 수 있는 실무 버그 사례를 하나 들어보세요.

# 함수 디폴트 파라미터가 list일 경우 다음 호출에 상태가 유지되어 버그 발생.

def f(x=[]): x.append(1); return x  
f()
# → [1]  
f()
# → [1,1]
f()
# → [1,1,1]

# 왜 이렇게 나오는지 이해하기
# 함수 디폴트 파라미터가 list일 경우 다음 호출에 상태가 유지되어 버그 발생.
# 즉, f()를 호출할 때마다 리스트에 1이 추가되어 버그 발생.


# ✅ 정답 예시
# 함수의 디폴트 파라미터에 list 같은 가변 객체를 사용했을 때,
# 여러 번 호출해도 동일한 객체가 재사용되어 상태가 계속 누적되는 버그가 발생할 수 있습니다.


# 📌 문제 코드
def f(x=[]):
    x.append(1)
    return x

print(f())  # [1]
print(f())  # [1, 1]
print(f())  # [1, 1, 1]


# 🧠 왜 이런 일이 발생할까?
# 파이썬에서 함수의 디폴트 인자는 함수가 정의되는 시점에 단 한 번만 평가됩니다.

# 따라서 x=[]는 함수가 호출될 때마다 새로운 리스트가 만들어지는 것이 아니라,
# 처음 만들어진 리스트가 계속 재사용됩니다.


# 📦 메모리 구조
# 함수 정의 시:

# def f(x=[]): ...
# 
#         ▼
#    [1, 1, 1]  ← 함수 호출 때마다 이 하나의 리스트가 계속 append됨!


# ❗️ 이 문제의 심각성
# 개발자가 전혀 의도하지 않은 방식으로 값이 공유됨
# API 설계나 클래스 내 메서드에서 상태 누적/오염으로 이어질 수 있음
#디버깅 시 원인 파악이 어렵고 불안정한 결과 초래


✅ 올바른 방식: None + 초기화
def f(x=None):
    if x is None:
        x = []
    x.append(1)
    return x

print(f())  # [1]
print(f())  # [1]
print(f())  # [1]


# 🔍 왜 이렇게 하면 안전할까?
# None은 불변 객체
# 함수가 호출될 때마다 x is None 조건을 만족하면 새로운 리스트가 생성됨
# 결과적으로 각 호출마다 독립적인 리스트가 사용됨


# 💬 실무 요약 팁
# 항목	피해야 할 방식	권장 방식
# 가변 디폴트 인자	def f(x=[])	def f(x=None) + 내부에서 초기화
# 원인	함수 정의 시 1회 평가	함수 호출 시마다 새 객체 생성 가능


# ✅ 최종 정리 예시 (Q11 답안)
# 리스트는 가변 객체이므로, 함수의 디폴트 파라미터로 사용될 경우
# 이전 호출의 변경 사항이 다음 호출에도 영향을 미치는 버그가 발생할 수 있습니다.
# 예를 들어, 아래 코드는 x가 호출마다 재사용되어 리스트에 값이 누적됩니다:

def f(x=[]):
    x.append(1)
    return x

f()  # [1]
f()  # [1, 1]
f()  # [1, 1, 1]

# 이러한 문제를 피하려면, None을 기본값으로 설정한 뒤 함수 내부에서 새 리스트를 만들어야 합니다:

def f(x=None):
    if x is None:
        x = []
    x.append(1)
    return x

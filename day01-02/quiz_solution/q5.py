Q5. 파이썬의 작은 정수 캐싱 범위를 알고 있나요? 다음 코드를 보고 예측하세요.

x = 256
y = 256
z = 1000
w = 1000
print(x is y)
print(z is w)

# 출력
# True
# False

# 왜 이렇게 나오는지 이해하기
# 파이썬은 -5 ~ 256 까지의 정수는 캐시되어 있어서, 같은 객체를 참조하고 있기 때문에, x is y는 True가 나온다.
# x와 y는 같은 객체를 참조하고 있기 때문에, x is y는 True가 나온다.
# z와 w는 같은 객체를 참조하고 있지 않기 때문에, z is w는 False가 나온다.


# ✅ 왜 이렇게 되나요?
# 🔍 파이썬의 작은 정수 캐싱(Small Integer Cache)
# 파이썬은 자주 쓰이는 정수 객체를 미리 만들어 두고 재사용합니다.

# 이 범위는 -5 ~ 256 이며, 이 범위 내의 정수는 항상 동일한 객체를 참조합니다.

# 즉, x = 256, y = 256 → 둘 다 같은 메모리 주소의 객체를 참조


# 🧠 시각적 이해
# x = 256   →   ─┐
# y = 256   →   ─┘   ▶ [정수 객체: 256]  (캐시된 동일 객체)

# z = 1000  →   ▶ [정수 객체: 1000A]
# w = 1000  →   ▶ [정수 객체: 1000B]


# 🔍 실제 메모리 주소 확인
# 🧪 실험해보기

x = 256
y = 256
print(id(x), id(y))  # 같은 ID

z = 1000
w = 1000
print(id(z), id(w))  # 다를 수 있음

# (단, 대화형 셸이나 최적화가 있는 경우 동일해질 수도 있습니다 — 항상 보장되지는 않음)


# 🔁 어떤 값이 캐시되는가?
# 값	          캐싱 여부	이유
# -5 ~ 256	 ✅ 항상 캐싱	  파이썬 구현(Python/C API)에서 명시
# 257 이상	  ❌ 보장되지 않음	매번 새 객체 생성될 수 있음
#-6 이하	      ❌ 보장되지 않음	작은 음수는 캐시 대상 아님


⚠️ ==와 is를 구분하자

a = 1000
b = 1000
print(a == b)   # True (값이 같음)
print(a is b)   # False (객체가 다름)

# == → 값(value) 비교
# is → 객체(identity) 비교


#🔍 최적화의 예외
# 일부 인터프리터(특히 REPL 또는 CPython -O 모드)는 같은 숫자 리터럴을 같은 객체로 최적화할 수 있으므로 z is w가 True가 나오는 예외적인 경우도 있을 수 있습니다.
하지만 일반적으로 파일 내 코드 또는 함수 안에서는 False가 나옵니다.


# ✨ 요약
# 파이썬은 -5 ~ 256 범위의 정수를 캐시
# x is y는 객체 참조가 같을 때만 True
# ==는 값만 같으면 True
#숫자 비교에서는 is 대신 ==를 써야 함

